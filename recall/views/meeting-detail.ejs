<%- include('partials/header') -%>
<style>
  /* Hide scrollbar for Chrome, Safari and Opera */
  .scrollbar-hide::-webkit-scrollbar {
    display: none;
  }
  /* Hide scrollbar for IE, Edge and Firefox */
  .scrollbar-hide {
    -ms-overflow-style: none;  /* IE and Edge */
    scrollbar-width: none;  /* Firefox */
  }
</style>
<div class="min-h-full">
  <%- include('partials/navigation', { user: user, currentPage: 'meetings' }) -%>
  <%- include('partials/notice', { notice: notice }) -%>
  <div class="py-10">
    <%- include('partials/meeting-detail/header', { meeting: meeting }) -%>
    <main>
      <div class="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8 mt-8">
        <div class="grid grid-cols-1 gap-6 lg:grid-cols-12">
          <!-- Main content column: full-width tabbed interface -->
          <div class="lg:col-span-12 w-full">
            <%- include('partials/meeting-detail/tabs', { meeting: meeting, publishDeliveries: publishDeliveries }) -%>


          </div>

        </div>
      </div>
    </main>
  </div>
</div>

<%- include('partials/meeting-detail/actions-drawer', { meeting: meeting }) -%>

<script type="application/json" id="meeting-client-bootstrap"><%- JSON.stringify({
  meetingId: meeting.readableId || meeting.id,
  artifactId: meeting.artifactId || "",
  topicsData: meeting.topics || [],
  meetingSummaryText: meeting.summary || "",
  superAgentEnabled: !!meeting.superAgentEnabled,
  hasPremiumAccess: !!meeting.hasPremiumAccess,
  initialSuperAgentAnalysis: meeting.superAgentAnalysis || null,
  lazyLoadTranscript: !!meeting.lazyLoadTranscript,
  transcriptChunkCount: meeting.transcriptChunkCount || 0,
  shareMeetingId: meeting.id,
  isOwner: !!meeting.isOwner,
  meetingTitle: meeting.title || "",
}) %></script>

<script>
  const meetingBootstrap = JSON.parse(
    document.getElementById('meeting-client-bootstrap')?.textContent || '{}'
  );
  // Store meeting ID for use in JavaScript (could be UUID or readableId)
  const meetingId = String(meetingBootstrap.meetingId || '');
  const artifactId = String(meetingBootstrap.artifactId || '');
  const topicsData = Array.isArray(meetingBootstrap.topicsData) ? meetingBootstrap.topicsData : [];
  const meetingSummaryText = String(meetingBootstrap.meetingSummaryText || '');
  const superAgentEnabled = !!meetingBootstrap.superAgentEnabled;
  const hasPremiumAccess = !!meetingBootstrap.hasPremiumAccess;
  const initialSuperAgentAnalysis = meetingBootstrap.initialSuperAgentAnalysis || null;
  const lazyLoadTranscript = !!meetingBootstrap.lazyLoadTranscript;
  const transcriptChunkCount = Number(meetingBootstrap.transcriptChunkCount || 0);
  const shareMeetingId = String(meetingBootstrap.shareMeetingId || '');
  const isOwner = !!meetingBootstrap.isOwner;
  const meetingTitle = String(meetingBootstrap.meetingTitle || '');
  
  // Lazy loading state
  let transcriptLoaded = false;
  let transcriptLoading = false;
  let currentTier = 'standard';
  let currentTab = { standard: 'summary', premium: 'summary' };

  // Format all datetime elements to user's local timezone
  document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('.local-datetime').forEach(function(el) {
      const iso = el.getAttribute('data-iso');
      const format = el.getAttribute('data-format');
      if (!iso) return;
      
      const date = new Date(iso);
      let formatted = '';
      
      if (format === 'date') {
        formatted = date.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric' });
      } else if (format === 'time') {
        formatted = date.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });
      } else if (format === 'datetime') {
        formatted = date.toLocaleDateString(undefined, { weekday: 'short', month: 'short', day: 'numeric', year: 'numeric' }) + 
                    ' at ' + 
                    date.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });
      } else if (format === 'full') {
        formatted = date.toLocaleDateString(undefined, { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' }) + 
                    ' at ' + 
                    date.toLocaleTimeString(undefined, { hour: 'numeric', minute: '2-digit' });
      }
      
      el.textContent = formatted;
    });

    // Apply server-computed widths without embedding EJS in CSS
    document.querySelectorAll('[data-width-pct]').forEach(function(el) {
      const pct = Number(el.getAttribute('data-width-pct'));
      if (Number.isNaN(pct)) return;
      el.style.width = `${pct}%`;
    });

    switchTier('standard', { focus: false });
    switchTab('summary', 'standard', { focus: false });

    // Set up keyboard navigation for tier-specific tabs
    document.querySelectorAll('.tab-btn-standard, .tab-btn-premium').forEach((tab) => {
      tab.addEventListener('keydown', (event) => {
        const isHorizontal = event.key === 'ArrowRight' || event.key === 'ArrowLeft';
        const isEdge = event.key === 'Home' || event.key === 'End';
        if (!isHorizontal && !isEdge) return;
        event.preventDefault();

        const tier = tab.classList.contains('tab-btn-standard') ? 'standard' : 'premium';
        const tabButtons = Array.from(document.querySelectorAll(`.tab-btn-${tier}`));
        const currentIndex = tabButtons.indexOf(tab);

        let nextIndex = currentIndex;
        if (event.key === 'ArrowRight') {
          nextIndex = (currentIndex + 1) % tabButtons.length;
        } else if (event.key === 'ArrowLeft') {
          nextIndex = (currentIndex - 1 + tabButtons.length) % tabButtons.length;
        } else if (event.key === 'Home') {
          nextIndex = 0;
        } else if (event.key === 'End') {
          nextIndex = tabButtons.length - 1;
        }

        const nextTab = tabButtons[nextIndex];
        const tabId = nextTab?.id;
        if (tabId) {
          const tabName = tabId.replace(`tab-${tier}-`, '');
          switchTab(tabName, tier, { focus: true });
        }
      });
    });

    initializeSuperAgent();
  });

  // Tab switching functionality
  function switchTier(tier, options = {}) {
    if (tier !== 'standard' && tier !== 'premium') return;
    currentTier = tier;

    document.querySelectorAll('.tier-btn').forEach(btn => {
      const isActive = btn.getAttribute('data-tier-target') === tier;
      btn.classList.toggle('border-indigo-500', isActive);
      btn.classList.toggle('text-indigo-600', isActive);
      btn.classList.toggle('border-transparent', !isActive);
      btn.classList.toggle('text-gray-500', !isActive);
      btn.setAttribute('aria-selected', isActive ? 'true' : 'false');
      btn.setAttribute('tabindex', isActive ? '0' : '-1');
    });

    // Show/hide tier-specific tab navigation bars
    document.querySelectorAll('[data-tier]').forEach(el => {
      const elTier = el.getAttribute('data-tier');
      if (!elTier) return;
      el.classList.toggle('hidden', elTier !== tier);
    });

    // Restore the last active tab for this tier
    const lastTab = currentTab[tier] || 'summary';
    switchTab(lastTab, tier, { focus: false });

    const tierSelect = document.getElementById('tier-select');
    if (tierSelect && tierSelect.value !== tier) {
      tierSelect.value = tier;
    }
  }

  function switchTab(tabName, tierOrOptions = null, options = {}) {
    // Handle tier switching from tab select
    if (tabName === 'tier-standard' || tabName === 'tier-premium') {
      switchTier(tabName.replace('tier-', ''), { focus: false });
      const tabSelect = document.getElementById('tab-select');
      if (tabSelect) {
        tabSelect.value = currentTab[currentTier];
      }
      return;
    }

    // Handle backward compatibility: if second param is an object with 'focus' property, treat it as options
    let targetTier = currentTier;
    let actualOptions = options;
    if (tierOrOptions !== null && typeof tierOrOptions === 'object' && !Array.isArray(tierOrOptions)) {
      if ('focus' in tierOrOptions || Object.keys(tierOrOptions).length === 0) {
        // It's an options object, not a tier
        actualOptions = tierOrOptions;
      } else if (tierOrOptions === 'standard' || tierOrOptions === 'premium') {
        targetTier = tierOrOptions;
      }
    } else if (tierOrOptions === 'standard' || tierOrOptions === 'premium') {
      targetTier = tierOrOptions;
    }
    
    const targetContent = document.getElementById('content-' + tabName);
    const activeTab = document.getElementById('tab-' + targetTier + '-' + tabName);
    if (!targetContent || !activeTab) return;

    // Store the active tab for this tier
    currentTab[targetTier] = tabName;

    // Hide all tab content
    document.querySelectorAll('.tab-content').forEach(content => {
      content.classList.add('hidden');
    });
    
    // Reset all tabs for this tier
    document.querySelectorAll(`.tab-btn-${targetTier}`).forEach(btn => {
      btn.classList.remove('border-indigo-500', 'text-indigo-600');
      btn.classList.add('border-transparent', 'text-gray-500', 'hover:border-gray-300', 'hover:text-gray-700');
      btn.setAttribute('aria-selected', 'false');
      btn.setAttribute('tabindex', '-1');
    });
    
    // Show the target content
    targetContent.classList.remove('hidden');
    
    // Activate the selected tab
    activeTab.classList.remove('border-transparent', 'text-gray-500', 'hover:border-gray-300', 'hover:text-gray-700');
    activeTab.classList.add('border-indigo-500', 'text-indigo-600');
    activeTab.setAttribute('aria-selected', 'true');
    activeTab.setAttribute('tabindex', '0');

    const tabSelect = document.getElementById('tab-select');
    if (tabSelect && tabSelect.value !== tabName) {
      tabSelect.value = tabName;
    }

    if (actualOptions.focus) {
      activeTab.focus();
    }
    
    // Trigger lazy loading for transcript tab
    if (tabName === 'transcript' && lazyLoadTranscript && !transcriptLoaded && !transcriptLoading) {
      loadTranscript();
    }
  }
  
  // Lazy load transcript from API
  async function loadTranscript() {
    if (transcriptLoaded || transcriptLoading) return;
    
    transcriptLoading = true;
    const loadingEl = document.getElementById('transcript-loading');
    const contentEl = document.getElementById('transcript-content');
    const errorEl = document.getElementById('transcript-error');
    
    // Show loading state
    if (loadingEl) loadingEl.classList.remove('hidden');
    if (contentEl) contentEl.classList.add('hidden');
    if (errorEl) errorEl.classList.add('hidden');
    
    try {
      const response = await fetch(`/api/meetings/${meetingId}/transcript`);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      const data = await response.json();
      const transcript = data.transcript || [];
      
      // Render transcript
      renderTranscript(transcript);
      
      transcriptLoaded = true;
      
      // Hide loading, show content
      if (loadingEl) loadingEl.classList.add('hidden');
      if (contentEl) contentEl.classList.remove('hidden');
      
    } catch (error) {
      console.error('Failed to load transcript:', error);
      
      // Show error state
      if (loadingEl) loadingEl.classList.add('hidden');
      if (errorEl) {
        errorEl.classList.remove('hidden');
        const errorMsg = document.getElementById('transcript-error-message');
        if (errorMsg) {
          errorMsg.textContent = error.message || 'An error occurred while loading the transcript.';
        }
      }
    } finally {
      transcriptLoading = false;
    }
  }
  
  // Render transcript HTML
  function renderTranscript(transcript) {
    const contentEl = document.getElementById('transcript-content');
    if (!contentEl) return;
    
    if (!transcript || transcript.length === 0) {
      contentEl.innerHTML = `
        <div class="text-center py-8">
          <svg class="mx-auto h-12 w-12 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"></path>
          </svg>
          <h3 class="mt-2 text-sm font-semibold text-gray-900">No transcript available</h3>
          <p class="mt-1 text-sm text-gray-500">The meeting transcript will appear here once it's processed.</p>
        </div>
      `;
      return;
    }
    
    // Speaker color palette
    const speakerPalette = ['indigo', 'blue', 'purple', 'emerald', 'amber', 'rose'];
    const speakerColorMap = {};
    
    function getSpeakerColor(name) {
      const str = name || 'Speaker';
      if (!speakerColorMap[str]) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          hash = (hash << 5) - hash + str.charCodeAt(i);
          hash |= 0;
        }
        speakerColorMap[str] = speakerPalette[Math.abs(hash) % speakerPalette.length];
      }
      return speakerColorMap[str];
    }
    
    function formatTime(ms) {
      if (!ms && ms !== 0) return '';
      const mins = Math.floor(ms / 60000);
      const secs = Math.floor((ms % 60000) / 1000);
      return `${mins}:${String(secs).padStart(2, '0')}`;
    }
    
    let html = '<div class="max-h-[calc(100vh-300px)] min-h-[400px] overflow-y-auto w-full"><div class="w-full space-y-4 pb-4 px-4 sm:px-6 lg:px-8">';
    let currentSpeaker = null;
    
    transcript.forEach((chunk) => {
      const showSpeaker = chunk.speaker !== currentSpeaker;
      currentSpeaker = chunk.speaker;
      const color = getSpeakerColor(chunk.speaker);
      const time = formatTime(chunk.timestamp || chunk.startTimeMs);
      
      html += `<div class="w-full ${showSpeaker ? 'pt-3 border-t border-gray-100' : ''}">`;
      
      if (showSpeaker) {
        html += `
          <div class="flex items-center mb-1">
            <span class="inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium bg-${color}-100 text-${color}-800">
              <svg class="mr-1 h-3 w-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
              </svg>
              ${escapeHtml(chunk.speaker || 'Speaker')}
            </span>
            ${time ? `<span class="ml-2 text-xs text-gray-400">${time}</span>` : ''}
          </div>
        `;
      }
      
      html += `<p class="w-full text-sm text-gray-700 text-left">${escapeHtml(chunk.text || '')}</p>`;
      html += '</div>';
    });
    
    // Add transcript count info INSIDE the scrollable container
    html += `
      <div class="pt-4 border-t border-gray-100 text-center">
        <p class="text-xs text-gray-400">${transcript.length.toLocaleString()} transcript segments loaded</p>
      </div>
    `;
    
    html += '</div></div>';
    
    contentEl.innerHTML = html;
  }
  
  // HTML escape helper
  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  let actionsDrawerLastFocus = null;

  function openActionsDrawer() {
    const drawer = document.getElementById('actions-drawer');
    if (!drawer) return;
    actionsDrawerLastFocus = document.activeElement;
    drawer.classList.remove('hidden');
    document.body.classList.add('overflow-hidden');
    const focusTarget = drawer.querySelector('button, [href], input, select, textarea');
    if (focusTarget) {
      focusTarget.focus();
    }
  }

  function closeActionsDrawer() {
    const drawer = document.getElementById('actions-drawer');
    if (!drawer) return;
    drawer.classList.add('hidden');
    document.body.classList.remove('overflow-hidden');
    if (actionsDrawerLastFocus && typeof actionsDrawerLastFocus.focus === 'function') {
      actionsDrawerLastFocus.focus();
    }
  }

  document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
      const drawer = document.getElementById('actions-drawer');
      if (drawer && !drawer.classList.contains('hidden')) {
        closeActionsDrawer();
      }
    }
  });

  function scrollToShareSection() {
    switchTab('summary', { focus: false });
    const section = document.getElementById('share-meeting-section');
    if (!section) {
      showNotification('Share section not available', 'error');
      return;
    }
    section.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  function copySummaryToClipboard() {
    const summaryEl = document.querySelector('#content-summary .prose');
    const text = (summaryEl?.innerText || meetingSummaryText || '').trim();
    if (!text) {
      showNotification('No summary to copy', 'error');
      return;
    }
    copyTextToClipboard(text);
  }

  // Topics accordion + helpers
  function topicTitleClient(topic, idx) {
    if (typeof topic === 'string') return topic || `Topic ${idx + 1}`;
    if (Array.isArray(topic)) return `Topic ${idx + 1}`;
    return topic.title || topic.name || topic.topic || topic.heading || topic.label || `Topic ${idx + 1}`;
  }

  function topicBulletsClient(topic) {
    if (typeof topic === 'string') return [topic];
    if (Array.isArray(topic)) return topic.map(item => typeof item === 'string' ? item : (item.text || item.summary || item.description || item.details || JSON.stringify(item)));
    // Check for array properties first (items, points, bullets, etc.)
    const arrayKeys = ['items', 'points', 'bullets', 'notes', 'entries', 'highlights', 'list'];
    for (const key of arrayKeys) {
      if (Array.isArray(topic[key]) && topic[key].length > 0) {
        return topic[key].map(item => typeof item === 'string' ? item : (item.text || item.summary || item.description || item.details || item.content || item.note || JSON.stringify(item)));
      }
    }
    // Handle AssemblyAI format: {topic: "title", details: "description"}
    if (topic.details && typeof topic.details === 'string') return [topic.details];
    if (topic.summary) return [topic.summary];
    if (topic.description) return [topic.description];
    if (topic.content) return [topic.content];
    if (topic.text) return [topic.text];
    // Don't return JSON.stringify for objects with only topic/title property
    const keys = Object.keys(topic).filter(k => !['topic', 'title', 'name', 'heading', 'label', 'id', 'index'].includes(k));
    if (keys.length === 0) return ['No details available'];
    return [JSON.stringify(topic)];
  }

  function parseTimecodeToSeconds(text) {
    if (typeof text === 'number' && !Number.isNaN(text)) return text;
    if (!text || typeof text !== 'string') return null;
    const match = text.match(/(\d{1,2}:)?\d{1,2}:\d{2}/);
    if (!match) return null;
    const parts = match[0].split(':').map(Number);
    if (parts.length === 3) return parts[0] * 3600 + parts[1] * 60 + parts[2];
    return parts[0] * 60 + parts[1];
  }

  function formatSecondsLabel(sec) {
    const hours = Math.floor(sec / 3600);
    const minutes = Math.floor((sec % 3600) / 60);
    const seconds = Math.floor(sec % 60);
    if (hours > 0) return `${hours}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    return `${minutes}:${String(seconds).padStart(2, '0')}`;
  }

  function toggleTopicAccordion(idx) {
    const panel = document.getElementById(`topic-panel-${idx}`);
    const chevron = document.getElementById(`topic-chevron-${idx}`);
    if (!panel) return;
    const isHidden = panel.classList.contains('hidden');
    panel.classList.toggle('hidden', !isHidden);
    panel.setAttribute('aria-hidden', (!isHidden).toString());
    if (chevron) {
      chevron.classList.toggle('rotate-90', isHidden);
      chevron.classList.toggle('rotate-0', !isHidden);
    }
  }

  function toggleTopicAccordionFromEvent(event) {
    const idx = Number(event?.currentTarget?.getAttribute?.('data-topic-idx'));
    if (!Number.isFinite(idx)) return;
    toggleTopicAccordion(idx);
  }

  function copyTextToClipboard(text) {
    if (!text) return;
    if (navigator.clipboard && navigator.clipboard.writeText) {
      navigator.clipboard.writeText(text)
        .then(() => showNotification('Copied to clipboard', 'success'))
        .catch(() => fallbackCopy(text));
    } else {
      fallbackCopy(text);
    }
  }

  function fallbackCopy(text) {
    const textarea = document.createElement('textarea');
    textarea.value = text;
    document.body.appendChild(textarea);
    textarea.select();
    try {
      document.execCommand('copy');
      showNotification('Copied to clipboard', 'success');
    } catch (err) {
      console.error('Clipboard copy failed', err);
      showNotification('Failed to copy', 'error');
    }
    document.body.removeChild(textarea);
  }

  function copyTopic(idx, event) {
    if (event) event.stopPropagation();
    const topic = topicsData[idx];
    if (!topic) {
      showNotification('Nothing to copy for this topic', 'error');
      return;
    }
    const title = topicTitleClient(topic, idx);
    const bullets = topicBulletsClient(topic);
    const body = bullets.map(item => `- ${typeof item === 'string' ? item : (item.text || item.summary || item.description || item.content || item.note || JSON.stringify(item))}`).join('\n');
    copyTextToClipboard(`${title}\n${body}`);
  }

  function copyTopicFromEvent(event) {
    const idx = Number(event?.currentTarget?.getAttribute?.('data-topic-idx'));
    if (!Number.isFinite(idx)) return;
    copyTopic(idx, event);
  }

  function copyAllTopics() {
    if (!topicsData || !topicsData.length) {
      showNotification('No topics to copy', 'error');
      return;
    }
    const sections = topicsData.map((topic, idx) => {
      const title = topicTitleClient(topic, idx);
      const bullets = topicBulletsClient(topic);
      const body = bullets.map(item => `- ${typeof item === 'string' ? item : (item.text || item.summary || item.description || item.content || item.note || JSON.stringify(item))}`).join('\n');
      return `${title}\n${body}`;
    }).join('\n\n');
    copyTextToClipboard(sections);
  }

  function jumpToTimestamp(seconds) {
    if (typeof seconds !== 'number' || Number.isNaN(seconds)) return;
    const videoContainer = document.getElementById('video-player-container');
    const audioContainer = document.getElementById('audio-player-container');
    const video = document.getElementById('video-player');
    const audio = document.getElementById('audio-player');

    if (video && videoContainer && videoContainer.classList.contains('hidden')) {
      toggleMedia('video');
    }

    const target = video || audio;
    if (target) {
      try {
        target.currentTime = seconds;
        if (target.pause) {
          target.play().catch(() => {
            showNotification('Jumped to timestamp; press play to continue', 'info');
          });
        }
      } catch (err) {
        console.error('Seek failed', err);
        showNotification('Could not seek to timestamp', 'error');
      }
    }
  }

  function jumpToTimestampFromEvent(event) {
    const seconds = Number(event?.currentTarget?.getAttribute?.('data-ts-seconds'));
    if (!Number.isFinite(seconds)) return;
    jumpToTimestamp(seconds);
  }

  // Notification system
  function showNotification(message, type = 'info') {
    // Remove any existing notifications
    const existing = document.getElementById('enrichment-notification');
    if (existing) {
      existing.remove();
    }

    const notification = document.createElement('div');
    notification.id = 'enrichment-notification';
    notification.className = `fixed top-4 right-4 z-50 max-w-sm w-full bg-white shadow-lg rounded-lg pointer-events-auto ring-1 ring-black ring-opacity-5 overflow-hidden`;
    
    const bgColor = type === 'success' ? 'bg-green-50' : type === 'error' ? 'bg-red-50' : 'bg-blue-50';
    const iconColor = type === 'success' ? 'text-green-400' : type === 'error' ? 'text-red-400' : 'text-blue-400';
    const textColor = type === 'success' ? 'text-green-800' : type === 'error' ? 'text-red-800' : 'text-blue-800';
    
    let iconSvg = '';
    if (type === 'success') {
      iconSvg = '<svg class="h-6 w-6 ' + iconColor + '" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
    } else if (type === 'error') {
      iconSvg = '<svg class="h-6 w-6 ' + iconColor + '" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>';
    } else {
      iconSvg = '<svg class="h-6 w-6 ' + iconColor + ' animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg>';
    }
    
    const hoverColor = textColor.replace('800', '600');
    
    notification.innerHTML = 
      '<div class="p-4 ' + bgColor + '">' +
        '<div class="flex items-start">' +
          '<div class="flex-shrink-0">' + iconSvg + '</div>' +
          '<div class="ml-3 w-0 flex-1">' +
            '<p class="text-sm font-medium ' + textColor + '">' + message + '</p>' +
          '</div>' +
          '<div class="ml-4 flex-shrink-0 flex">' +
            '<button onclick="this.closest(\'#enrichment-notification\').remove()" class="inline-flex ' + textColor + ' hover:' + hoverColor + ' focus:outline-none">' +
              '<svg class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">' +
                '<path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd"></path>' +
              '</svg>' +
            '</button>' +
          '</div>' +
        '</div>' +
      '</div>';
    
    document.body.appendChild(notification);
    
    // Auto-remove after 5 seconds for success/error, keep info notifications until manually closed
    if (type !== 'info') {
      setTimeout(() => {
        if (notification.parentNode) {
          notification.remove();
        }
      }, 5000);
    }
  }

  // Poll for summary completion
  async function pollForSummary(meetingId, maxAttempts = 60, intervalMs = 2000) {
    let attempts = 0;
    
    const poll = async () => {
      try {
        const response = await fetch(`/api/meetings/${meetingId}/summary`);
        if (!response.ok) {
          console.error(`[pollForSummary] API returned ${response.status}: ${response.statusText}`);
          attempts++;
          if (attempts >= maxAttempts) {
            return false;
          }
          await new Promise(resolve => setTimeout(resolve, intervalMs));
          return poll();
        }
        
        const data = await response.json();
        
        // Check if summary record exists (even if content is empty, the record existing means enrichment completed)
        // Also check if summary has actual content to avoid false positives from empty summaries
        if (data.summary !== null && data.summary !== undefined) {
          // Summary record exists - enrichment job completed
          // Check if it has content (non-empty string)
          const hasContent = data.summary.content && typeof data.summary.content === 'string' && data.summary.content.trim().length > 0;
          if (hasContent) {
            // Summary is ready with content!
            return true;
          } else {
            // Summary record exists but is empty - might be a valid state, but log it
            console.log('[pollForSummary] Summary record exists but content is empty');
            // Still return true to stop polling - the job completed even if summary is empty
            return true;
          }
        }
        
        attempts++;
        if (attempts >= maxAttempts) {
          // Timeout after max attempts
          console.warn(`[pollForSummary] Timeout after ${maxAttempts} attempts`);
          return false;
        }
        
        // Continue polling
        await new Promise(resolve => setTimeout(resolve, intervalMs));
        return poll();
      } catch (error) {
        console.error('[pollForSummary] Error polling for summary:', error);
        attempts++;
        if (attempts >= maxAttempts) {
          return false;
        }
        await new Promise(resolve => setTimeout(resolve, intervalMs));
        return poll();
      }
    };
    
    return poll();
  }

  // Enrichment trigger functionality
  async function triggerEnrichment(artifactId, buttonEl) {
    const btn = buttonEl || document.getElementById('enrich-btn');
    const btnText = (btn && btn.querySelector('[data-enrich-text]')) || document.getElementById('enrich-btn-text');
    if (!btn || !btnText) {
      showNotification('Unable to trigger enrichment from this view.', 'error');
      return;
    }
    
    // Disable button and show loading state
    btn.disabled = true;
    btn.classList.add('opacity-75', 'cursor-not-allowed');
    const originalText = btnText.textContent;
    btnText.innerHTML = '<svg class="animate-spin -ml-1 mr-2 h-4 w-4 inline" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Processing...';
    
    // Show "Please wait" notification
    showNotification('Please wait, generating AI summary... This may take a moment.', 'info');
    
    try {
      console.log(`[triggerEnrichment] Triggering enrichment for artifact ${artifactId}`);
      const response = await fetch('/api/meetings/enrich', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ artifactId }),
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error(`[triggerEnrichment] API error ${response.status}:`, errorText);
        throw new Error(`Server error: ${response.status} ${response.statusText}`);
      }
      
      const result = await response.json();
      console.log('[triggerEnrichment] Enrichment API response:', result);
      
      if (!result.success) {
        throw new Error(result.error || 'Failed to trigger enrichment');
      }
      
      console.log(`[triggerEnrichment] Enrichment job queued successfully, starting to poll for meeting ${meetingId}`);
      
      // Start polling for summary completion
      btnText.innerHTML = '<svg class="animate-spin -ml-1 mr-2 h-4 w-4 inline" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg> Generating...';
      
      const summaryReady = await pollForSummary(meetingId);
      
      if (summaryReady) {
        // Success! Show notification and refresh page
        console.log('[triggerEnrichment] Summary ready, refreshing page');
        showNotification('AI summary generated successfully! Refreshing page...', 'success');
        
        // Refresh page after a short delay to show the notification
        setTimeout(() => {
          window.location.reload();
        }, 1500);
      } else {
        // Timeout - show message that it's still processing
        console.warn('[triggerEnrichment] Summary not ready after initial polling, continuing in background');
        showNotification('Summary generation is taking longer than expected. The page will refresh automatically when complete.', 'info');
        btnText.textContent = 'Still processing...';
        
        // Continue polling in background and refresh when ready
        setTimeout(async () => {
          console.log('[triggerEnrichment] Starting extended polling');
          const ready = await pollForSummary(meetingId, 120, 3000); // Poll for up to 6 more minutes
          if (ready) {
            console.log('[triggerEnrichment] Summary ready after extended polling');
            showNotification('AI summary generated successfully!', 'success');
            setTimeout(() => {
              window.location.reload();
            }, 1500);
          } else {
            console.error('[triggerEnrichment] Summary still not ready after extended polling');
            showNotification('Summary generation is still in progress. Please check back later or refresh the page.', 'info');
          }
        }, 5000);
      }
    } catch (error) {
      console.error('Enrichment error:', error);
      showNotification('Error: ' + error.message, 'error');
      btnText.textContent = 'Error: ' + error.message;
      btn.classList.remove('opacity-75', 'cursor-not-allowed');
      btn.disabled = false;
      
      // Reset button text after 5 seconds
      setTimeout(() => {
        btnText.textContent = originalText;
      }, 5000);
    }
  }

  let superAgentPollTimer = null;

  function openSuperAgentPanel() {
    switchTier('premium', { focus: false });
    switchTab('summary', 'premium', { focus: false });
    const section = document.getElementById('super-agent-section');
    if (section) {
      section.scrollIntoView({ behavior: 'smooth', block: 'start' });
    }
  }

  function getSuperAgentFeatures() {
    const translateSelect = document.getElementById('super-agent-translate');
    const translateTo = translateSelect && translateSelect.value ? [translateSelect.value] : [];
    return {
      translateTo,
      topicDetection: !!document.getElementById('super-agent-topic')?.checked,
      contentModeration: !!document.getElementById('super-agent-moderation')?.checked,
      piiRedaction: !!document.getElementById('super-agent-pii')?.checked,
      profanityFiltering: !!document.getElementById('super-agent-profanity')?.checked,
      sentimentAnalysis: !!document.getElementById('super-agent-sentiment')?.checked,
    };
  }

  function setSuperAgentStatus(status, message) {
    const pill = document.getElementById('super-agent-status-pill');
    if (!pill) return;
    const label = message || status || 'Not started';
    pill.textContent = label;
    pill.className = 'inline-flex items-center rounded-full px-2.5 py-1 text-xs font-medium ring-1 ring-inset';

    if (status === 'completed') {
      pill.classList.add('bg-green-50', 'text-green-700', 'ring-green-600/20');
    } else if (status === 'processing' || status === 'queued') {
      pill.classList.add('bg-amber-50', 'text-amber-700', 'ring-amber-600/20');
    } else if (status === 'error') {
      pill.classList.add('bg-red-50', 'text-red-700', 'ring-red-600/20');
    } else {
      pill.classList.add('bg-gray-100', 'text-gray-600', 'ring-gray-300');
    }
  }

  function renderSuperAgentAnalysis(analysis) {
    try {
      // Debug: Log what we're rendering
      console.log('[Super Agent] renderSuperAgentAnalysis called with:', {
        hasAnalysis: !!analysis,
        status: analysis?.status,
        hasDetailedSummary: !!analysis?.detailedSummary,
        detailedSummaryLength: analysis?.detailedSummary?.length,
        hasChapters: !!analysis?.chapters?.length,
        chaptersCount: analysis?.chapters?.length,
        hasActionItems: !!analysis?.actionItems?.length,
        actionItemsCount: analysis?.actionItems?.length,
        hasDecisions: !!analysis?.decisions?.length,
        decisionsCount: analysis?.decisions?.length,
        hasHighlights: !!analysis?.highlights?.length,
        highlightsCount: analysis?.highlights?.length
      });
    
    const progress = document.getElementById('super-agent-progress');
    const results = document.getElementById('super-agent-results');
    const errorEl = document.getElementById('super-agent-error');
    const triggerBtn = document.getElementById('super-agent-trigger');
    
    // Debug: Check if elements exist
    console.log('[Super Agent] DOM elements:', {
      hasProgress: !!progress,
      hasResults: !!results,
      hasError: !!errorEl,
      hasTriggerBtn: !!triggerBtn,
      resultsHidden: results?.classList.contains('hidden')
    });

    if (!analysis) {
      setSuperAgentStatus('idle', 'Not started');
      if (progress) progress.classList.add('hidden');
      if (results) results.classList.add('hidden');
      if (errorEl) errorEl.classList.add('hidden');
      if (triggerBtn) {
        triggerBtn.disabled = !superAgentEnabled;
        triggerBtn.textContent = superAgentEnabled ? 'Analyse with Super Agent' : 'Super Agent disabled';
      }
      return;
    }

    const status = analysis.status || 'processing';
    setSuperAgentStatus(status, status === 'queued' ? 'Queued' : status);

    if (progress) {
      progress.classList.toggle('hidden', !(status === 'processing' || status === 'queued'));
      progress.classList.toggle('flex', status === 'processing' || status === 'queued');
    }

    if (errorEl) {
      if (status === 'error') {
        errorEl.textContent = analysis.errorMessage || 'Super Agent failed. Please try again.';
        errorEl.classList.remove('hidden');
      } else {
        errorEl.classList.add('hidden');
      }
    }

    if (triggerBtn) {
      triggerBtn.disabled = status === 'processing' || status === 'queued';
      triggerBtn.textContent = status === 'completed' ? 'Re-run Super Agent' : 'Analyse with Super Agent';
    }

    if (results) {
      if (status === 'completed') {
        console.log('[Super Agent] Status is completed, showing results');
        results.classList.remove('hidden');
        console.log('[Super Agent] Results hidden class removed, now hidden?', results.classList.contains('hidden'));
        
        const summaryEl = document.getElementById('super-agent-summary');
        console.log('[Super Agent] Summary element:', {
          exists: !!summaryEl,
          summaryLength: analysis.detailedSummary?.length
        });
        if (summaryEl) summaryEl.textContent = analysis.detailedSummary || '';

        const chaptersEl = document.getElementById('super-agent-chapters');
        console.log('[Super Agent] Chapters element:', {
          exists: !!chaptersEl,
          chaptersCount: analysis.chapters?.length
        });
        if (chaptersEl) {
          const chapters = Array.isArray(analysis.chapters) ? analysis.chapters : [];
          console.log('[Super Agent] Rendering chapters:', chapters.length);
          chaptersEl.innerHTML = chapters.length
            ? chapters.map((chapter) => {
                const start = typeof chapter.start === 'number' ? Math.floor(chapter.start / 1000) : null;
                const end = typeof chapter.end === 'number' ? Math.floor(chapter.end / 1000) : null;
                const timeLabel = start !== null ? formatSecondsLabel(start) : null;
                const endLabel = end !== null ? formatSecondsLabel(end) : null;
                return `
                  <div class="rounded-md border border-gray-200 p-3">
                    <div class="flex items-center justify-between">
                      <div class="font-medium text-gray-900">${chapter.headline || chapter.gist || 'Chapter'}</div>
                      ${timeLabel ? `<div class="text-xs text-gray-500">${timeLabel}${endLabel ? `-${endLabel}` : ''}</div>` : ''}
                    </div>
                    <p class="mt-1 text-xs text-gray-600">${chapter.summary || ''}</p>
                  </div>
                `;
              }).join('')
            : '<p class="text-xs text-gray-500">No chapters available.</p>';
        }

        const actionsEl = document.getElementById('super-agent-actions');
        if (actionsEl) {
          const actions = Array.isArray(analysis.actionItems) ? analysis.actionItems : [];
          actionsEl.innerHTML = actions.length
            ? actions.map((item) => {
                const text = item.task || item.action || item.text || item.description || JSON.stringify(item);
                const assignee = item.assignee ? ` â€” ${item.assignee}` : '';
                return `<li class="flex items-start"><span class="mt-1 h-2 w-2 rounded-full bg-amber-400"></span><span class="ml-2">${text}${assignee}</span></li>`;
              }).join('')
            : '<li class="text-xs text-gray-500">No action items yet.</li>';
        }

        const decisionsEl = document.getElementById('super-agent-decisions');
        if (decisionsEl) {
          const decisions = Array.isArray(analysis.decisions) ? analysis.decisions : [];
          decisionsEl.innerHTML = decisions.length
            ? decisions.map((item) => {
                const text = item.decision || item.text || item.description || JSON.stringify(item);
                return `<li class="flex items-start"><span class="mt-1 h-2 w-2 rounded-full bg-purple-400"></span><span class="ml-2">${text}</span></li>`;
              }).join('')
            : '<li class="text-xs text-gray-500">No decisions captured.</li>';
        }

        const highlightsEl = document.getElementById('super-agent-highlights');
        if (highlightsEl) {
          const highlights = Array.isArray(analysis.highlights) ? analysis.highlights : [];
          highlightsEl.innerHTML = highlights.length
            ? highlights.map((item) => {
                const title = item.title || 'Highlight';
                const summary = item.summary || item.text || item.description || '';
                return `<li class="rounded-md border border-gray-200 p-3"><div class="text-sm font-semibold text-gray-900">${title}</div><p class="mt-1 text-xs text-gray-600">${summary}</p></li>`;
              }).join('')
            : '<li class="text-xs text-gray-500">No highlights available.</li>';
        }
      } else {
        results.classList.add('hidden');
      }
    }
    } catch (error) {
      console.error('[Super Agent] Error in renderSuperAgentAnalysis:', error);
    }
  }

  async function fetchSuperAgentAnalysis() {
    if (!meetingId || !artifactId) return null;
    try {
      const response = await fetch(`/api/meetings/${meetingId}/super-agent`);
      if (!response.ok) return null;
      const data = await response.json();
      return data.analysis || null;
    } catch (error) {
      console.error('Failed to fetch Super Agent analysis:', error);
      return null;
    }
  }

  function scheduleSuperAgentPoll() {
    if (superAgentPollTimer) {
      clearTimeout(superAgentPollTimer);
    }
    superAgentPollTimer = setTimeout(async () => {
      const analysis = await fetchSuperAgentAnalysis();
      if (analysis) {
        renderSuperAgentAnalysis(analysis);
        if (analysis.status === 'processing' || analysis.status === 'queued') {
          scheduleSuperAgentPoll();
        }
      }
    }, 4000);
  }

  async function triggerSuperAgentAnalysis() {
    if (!artifactId) {
      showNotification('Super Agent requires a processed recording.', 'error');
      return;
    }
    if (!superAgentEnabled) {
      showNotification('Super Agent is not enabled for this account.', 'error');
      return;
    }

    const triggerBtn = document.getElementById('super-agent-trigger');
    if (triggerBtn) {
      triggerBtn.disabled = true;
    }

    try {
      const response = await fetch(`/api/meetings/${meetingId}/super-agent/analyze`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ features: getSuperAgentFeatures() }),
      });

      const result = await response.json();
      if (!response.ok) {
        throw new Error(result.error || 'Failed to start Super Agent analysis');
      }

      renderSuperAgentAnalysis({ status: 'queued' });
      scheduleSuperAgentPoll();
      showNotification('Super Agent analysis queued.', 'success');
    } catch (error) {
      showNotification(error.message || 'Failed to start Super Agent', 'error');
      renderSuperAgentAnalysis({ status: 'error', errorMessage: error.message });
    }
  }

  async function retrySuperAgentAnalysis() {
    if (!meetingId) {
      showNotification('No meeting ID available', 'error');
      return;
    }

    const retryBtn = document.getElementById('super-agent-retry');
    if (retryBtn) {
      retryBtn.disabled = true;
      retryBtn.textContent = 'Retrying...';
    }

    try {
      const response = await fetch(`/api/meetings/${meetingId}/super-agent/retry`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
      });

      const result = await response.json();
      if (!response.ok) {
        throw new Error(result.error || 'Failed to retry Super Agent analysis');
      }

      showNotification('Retry queued - analysis will complete shortly', 'success');
      scheduleSuperAgentPoll();
    } catch (error) {
      showNotification(error.message || 'Failed to retry Super Agent', 'error');
    } finally {
      if (retryBtn) {
        retryBtn.disabled = false;
        retryBtn.textContent = 'Retry';
      }
    }
  }

  function initializeSuperAgent() {
    console.log('[Super Agent] initializeSuperAgent called', {
      hasArtifactId: !!artifactId,
      superAgentEnabled,
      hasInitialAnalysis: !!initialSuperAgentAnalysis,
      initialAnalysisStatus: initialSuperAgentAnalysis?.status
    });
    
    if (!artifactId) return;
    if (!superAgentEnabled) {
      console.log('[Super Agent] Super Agent not enabled');
      renderSuperAgentAnalysis(null);
      return;
    }
    console.log('[Super Agent] Rendering initial analysis');
    renderSuperAgentAnalysis(initialSuperAgentAnalysis);
    // Poll when there's no analysis yet, or when one is queued/processing (so we update when worker finishes)
    const inProgress = initialSuperAgentAnalysis && (initialSuperAgentAnalysis.status === 'processing' || initialSuperAgentAnalysis.status === 'queued');
    if (!initialSuperAgentAnalysis || inProgress) {
      console.log('[Super Agent] Scheduling poll');
      scheduleSuperAgentPoll();
    }
  }

  // Manual publish to Notion
  async function publishToNotion(artifactId, buttonEl) {
    const btn = buttonEl || document.getElementById('publish-btn');
    const btnText = (btn && btn.querySelector('[data-publish-text]')) || document.getElementById('publish-btn-text');
    if (!btn || !btnText) return;
    btn.disabled = true;
    btn.classList.add('opacity-75', 'cursor-not-allowed');
    const originalText = btnText.textContent;
    btnText.textContent = 'Queuing...';

    try {
      const response = await fetch(`/api/meetings/${artifactId}/publish`, {
        method: 'POST',
      });
      const result = await response.json();
      
      if (!response.ok) {
        // Handle specific error cases
        if (result.error === 'Notion not connected') {
          showNotification('Please connect your Notion account in Settings first.', 'error');
          btnText.textContent = 'Notion not connected';
        } else if (result.error === 'Notion destination not configured') {
          showNotification('Please configure a Notion destination in Settings first.', 'error');
          btnText.textContent = 'No destination configured';
        } else {
          throw new Error(result.message || result.error || 'Failed to queue publish');
        }
        btn.disabled = false;
        btn.classList.remove('opacity-75', 'cursor-not-allowed');
        setTimeout(() => (btnText.textContent = originalText), 5000);
        return;
      }
      
      if (result.success) {
        if (result.action === 'publish') {
          showNotification('Publishing to Notion... This may take a moment.', 'info');
          btnText.textContent = 'Publishing...';
          
          // Poll for publish completion (check publish deliveries)
          setTimeout(async () => {
            try {
              // Reload page after a delay to show updated publish status
              setTimeout(() => {
                window.location.reload();
              }, 3000);
            } catch (pollErr) {
              console.error('Error checking publish status:', pollErr);
            }
          }, 2000);
        } else {
          showNotification('Generating summary first, then will publish to Notion...', 'info');
          btnText.textContent = 'Enriching then publish';
          
          // Wait for summary, then publish
          const summaryReady = await pollForSummary(meetingId, 60, 2000);
          if (summaryReady) {
            showNotification('Summary ready! Publishing to Notion...', 'info');
            // The enrichment job should have triggered publishing automatically
            setTimeout(() => {
              window.location.reload();
            }, 3000);
          } else {
            showNotification('Summary generation is taking longer than expected. Publishing will happen automatically when ready.', 'info');
            btnText.textContent = 'Processing...';
          }
        }
      } else {
        throw new Error(result.error || 'Failed to queue publish');
      }
    } catch (err) {
      console.error('Publish error:', err);
      showNotification('Error: ' + err.message, 'error');
      btnText.textContent = 'Error: ' + err.message;
      btn.disabled = false;
      btn.classList.remove('opacity-75', 'cursor-not-allowed');
      setTimeout(() => (btnText.textContent = originalText), 5000);
    }
  }

  // Media toggle functionality
  function toggleMedia(mediaType) {
    const videoContainer = document.getElementById('video-player-container');
    const audioContainer = document.getElementById('audio-player-container');
    const videoBtn = document.getElementById('video-toggle-btn');
    const audioBtn = document.getElementById('audio-toggle-btn');

    if (mediaType === 'video') {
      if (videoContainer) videoContainer.classList.remove('hidden');
      if (audioContainer) audioContainer.classList.add('hidden');
      if (videoBtn) {
        videoBtn.classList.remove('bg-white', 'text-gray-700', 'ring-1', 'ring-inset', 'ring-gray-300');
        videoBtn.classList.add('bg-indigo-600', 'text-white');
      }
      if (audioBtn) {
        audioBtn.classList.remove('bg-indigo-600', 'text-white');
        audioBtn.classList.add('bg-white', 'text-gray-700', 'ring-1', 'ring-inset', 'ring-gray-300');
      }
    } else {
      if (videoContainer) videoContainer.classList.add('hidden');
      if (audioContainer) audioContainer.classList.remove('hidden');
      if (audioBtn) {
        audioBtn.classList.remove('bg-white', 'text-gray-700', 'ring-1', 'ring-inset', 'ring-gray-300');
        audioBtn.classList.add('bg-indigo-600', 'text-white');
      }
      if (videoBtn) {
        videoBtn.classList.remove('bg-indigo-600', 'text-white');
        videoBtn.classList.add('bg-white', 'text-gray-700', 'ring-1', 'ring-inset', 'ring-gray-300');
      }
    }
  }

  // Sharing functionality
  // shareMeetingId and isOwner come from meetingBootstrap
  
  // Load shareable attendees and current shares on page load
  if (isOwner) {
    loadShareableAttendees();
    loadCurrentShares();
  }
  
  async function loadShareableAttendees() {
    const container = document.getElementById('attendees-to-share');
    if (!container) return;
    
    try {
      const response = await fetch(`/api/meetings/${shareMeetingId}/shareable-attendees`);
      const data = await response.json();
      
      if (!response.ok) {
        container.innerHTML = '<p class="text-xs text-red-500">Failed to load attendees</p>';
        return;
      }
      
      if (!data.attendees || data.attendees.length === 0) {
        container.innerHTML = '<p class="text-xs text-gray-500">No attendees to share with</p>';
        return;
      }
      
      container.innerHTML = data.attendees.map(attendee => `
        <div class="flex items-center justify-between py-1">
          <div class="flex items-center">
            <div class="h-6 w-6 rounded-full bg-gray-200 flex items-center justify-center">
              <svg class="h-3 w-3 text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
              </svg>
            </div>
            <span class="ml-2 text-xs text-gray-700">${attendee.name || attendee.email}</span>
            ${attendee.isRegistered ? '<span class="ml-1 text-xs text-green-600">âœ“</span>' : ''}
          </div>
          ${attendee.isShared 
            ? '<span class="text-xs text-green-600">Shared</span>'
            : `<button 
                type="button" 
                onclick="shareWithAttendee('${attendee.email}')"
                class="text-xs text-indigo-600 hover:text-indigo-800"
              >Share</button>`
          }
        </div>
      `).join('');
    } catch (error) {
      console.error('Error loading attendees:', error);
      container.innerHTML = '<p class="text-xs text-red-500">Error loading attendees</p>';
    }
  }
  
  async function loadCurrentShares() {
    const container = document.getElementById('shares-list');
    if (!container) return;
    
    try {
      const response = await fetch(`/api/meetings/${shareMeetingId}/shares`);
      const data = await response.json();
      
      if (!response.ok) {
        container.innerHTML = '<p class="text-xs text-red-500">Failed to load shares</p>';
        return;
      }
      
      const activeShares = (data.shares || []).filter(s => s.status !== 'revoked');
      
      if (activeShares.length === 0) {
        container.innerHTML = '<p class="text-xs text-gray-500">Not shared with anyone yet</p>';
        return;
      }
      
      container.innerHTML = activeShares.map(share => {
        const shareLink = share.shareToken ? `${window.location.origin}/meetings/shared/${share.shareToken}` : null;
        return `
        <div class="py-2 border-b border-gray-100 last:border-0">
          <div class="flex items-center justify-between mb-1">
            <div class="flex items-center">
              <div class="h-6 w-6 rounded-full bg-indigo-100 flex items-center justify-center">
                <svg class="h-3 w-3 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                  <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path>
                </svg>
              </div>
              <span class="ml-2 text-xs text-gray-700">
                ${share.sharedWithUser?.name || share.sharedWithUser?.email || share.sharedWithEmail || 'Unknown'}
              </span>
              <span class="ml-2 text-xs text-gray-400 capitalize">(${share.accessLevel})</span>
            </div>
            <button 
              type="button" 
              onclick="revokeShare('${share.id}')"
              class="text-xs text-red-600 hover:text-red-800"
            >Revoke</button>
          </div>
          ${shareLink ? `
          <div class="mt-2 flex items-center gap-2">
            <input 
              type="text" 
              value="${shareLink}" 
              readonly 
              id="share-link-${share.id}"
              class="flex-1 text-xs px-2 py-1 bg-gray-50 border border-gray-200 rounded text-gray-600 font-mono"
              onclick="this.select()"
            >
            <button 
              type="button"
              onclick="copyShareLink('${share.id}', '${shareLink}')"
              class="text-xs px-2 py-1 bg-indigo-50 text-indigo-600 rounded hover:bg-indigo-100"
              title="Copy link"
            >
              <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
              </svg>
            </button>
          </div>
          ` : `
          <div class="mt-2">
            <button 
              type="button"
              onclick="generateShareToken('${share.id}')"
              class="text-xs px-2 py-1 bg-indigo-50 text-indigo-600 rounded hover:bg-indigo-100"
            >
              Generate Shareable Link
            </button>
          </div>
          `}
        </div>
      `;
      }).join('');
    } catch (error) {
      console.error('Error loading shares:', error);
      container.innerHTML = '<p class="text-xs text-red-500">Error loading shares</p>';
    }
  }
  
  async function shareMeeting() {
    const emailInput = document.getElementById('share-email');
    const email = emailInput?.value?.trim();
    
    if (!email) {
      showNotification('Please enter an email address', 'error');
      return;
    }
    
    try {
      const response = await fetch(`/api/meetings/${shareMeetingId}/shares`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, accessLevel: 'view' }),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        showNotification(data.error || 'Failed to share meeting', 'error');
        return;
      }
      
      showNotification(`Meeting shared with ${email}`, 'success');
      emailInput.value = '';
      loadShareableAttendees();
      loadCurrentShares();
    } catch (error) {
      console.error('Error sharing meeting:', error);
      showNotification('Failed to share meeting', 'error');
    }
  }
  
  async function shareWithAttendee(email) {
    try {
      const response = await fetch(`/api/meetings/${shareMeetingId}/shares`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ email, accessLevel: 'view' }),
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        showNotification(data.error || 'Failed to share meeting', 'error');
        return;
      }
      
      showNotification(`Meeting shared with ${email}`, 'success');
      loadShareableAttendees();
      loadCurrentShares();
    } catch (error) {
      console.error('Error sharing meeting:', error);
      showNotification('Failed to share meeting', 'error');
    }
  }
  
  async function revokeShare(shareId) {
    if (!confirm('Are you sure you want to revoke this share?')) return;
    
    try {
      const response = await fetch(`/api/meetings/${shareMeetingId}/shares/${shareId}`, {
        method: 'DELETE',
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        showNotification(data.error || 'Failed to revoke share', 'error');
        return;
      }
      
      showNotification('Share revoked', 'success');
      loadShareableAttendees();
      loadCurrentShares();
    } catch (error) {
      console.error('Error revoking share:', error);
      showNotification('Failed to revoke share', 'error');
    }
  }

  // ===== Notion Destination Picker =====
  let notionDestinations = [];
  let selectedDestinationId = null;
  let selectedDestinationType = null;
  let createNewPage = false;
  let customSubpageTitle = '';
  let publishArtifactId = null;

  async function openNotionDestinationPicker(artifactId) {
    publishArtifactId = artifactId;
    const modal = document.getElementById('notion-destination-modal');
    const listContainer = document.getElementById('notion-destinations-list');
    const loadingEl = document.getElementById('notion-destinations-loading');
    const errorEl = document.getElementById('notion-destinations-error');
    const searchInput = document.getElementById('notion-destination-search');
    
    // Reset state
    selectedDestinationId = null;
    selectedDestinationType = null;
    createNewPage = false;
    customSubpageTitle = '';
    searchInput.value = '';
    listContainer.innerHTML = '';
    loadingEl.classList.remove('hidden');
    errorEl.classList.add('hidden');
    document.getElementById('notion-publish-btn').disabled = true;
    updateCreateNewPageOption();
    
    // Show modal
    modal.classList.remove('hidden');
    
    // Fetch destinations
    try {
      const response = await fetch('/api/notion/destinations');
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.message || data.error || 'Failed to load destinations');
      }
      
      notionDestinations = data.destinations || [];
      selectedDestinationId = data.defaultDestinationId;
      
      // Find the type of the default destination
      if (selectedDestinationId) {
        const defaultDest = notionDestinations.find(d => d.id === selectedDestinationId);
        selectedDestinationType = defaultDest?.type || 'page';
      }
      
      renderNotionDestinations(notionDestinations);
      updateCreateNewPageOption();
    } catch (error) {
      console.error('Error loading Notion destinations:', error);
      errorEl.textContent = error.message || 'Failed to load Notion destinations. Please check your Notion connection.';
      errorEl.classList.remove('hidden');
    } finally {
      loadingEl.classList.add('hidden');
    }
  }

  function closeNotionDestinationPicker() {
    document.getElementById('notion-destination-modal').classList.add('hidden');
  }

  function renderNotionDestinations(destinations) {
    const listContainer = document.getElementById('notion-destinations-list');
    
    if (destinations.length === 0) {
      listContainer.innerHTML = `
        <div class="text-center py-8 text-gray-500">
          <p>No Notion pages or databases found.</p>
          <p class="text-sm mt-2">Make sure you've shared pages with the Recall integration in Notion.</p>
        </div>
      `;
      return;
    }
    
    // Group by type
    const databases = destinations.filter(d => d.type === 'database');
    const pages = destinations.filter(d => d.type === 'page');
    
    let html = '';
    
    if (databases.length > 0) {
      html += `<div class="mb-4">
        <h4 class="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-2">Databases (creates new page)</h4>
        <div class="space-y-1">
          ${databases.map(d => renderDestinationItem(d)).join('')}
        </div>
      </div>`;
    }
    
    if (pages.length > 0) {
      html += `<div>
        <h4 class="text-xs font-semibold text-gray-500 uppercase tracking-wide mb-2">Pages (appends content)</h4>
        <div class="space-y-1">
          ${pages.map(d => renderDestinationItem(d)).join('')}
        </div>
      </div>`;
    }
    
    listContainer.innerHTML = html;
    
    // Update button state
    document.getElementById('notion-publish-btn').disabled = !selectedDestinationId;
  }

  function renderDestinationItem(dest) {
    const isSelected = dest.id === selectedDestinationId;
    const icon = dest.icon || (dest.type === 'database' ? 'ðŸ“Š' : 'ðŸ“„');
    
    return `
      <button
        type="button"
        onclick="selectNotionDestination('${dest.id}', '${dest.type}')"
        class="w-full flex items-center px-3 py-2 rounded-lg text-left transition-colors ${
          isSelected 
            ? 'bg-indigo-50 ring-2 ring-indigo-500 text-indigo-700' 
            : 'hover:bg-gray-50 text-gray-700'
        }"
      >
        <span class="text-lg mr-3">${icon.length <= 2 ? icon : 'ðŸ“„'}</span>
        <div class="flex-1 min-w-0">
          <p class="text-sm font-medium truncate">${escapeHtml(dest.title)}</p>
          <p class="text-xs text-gray-500">${dest.type === 'database' ? 'Database' : 'Page'}</p>
        </div>
        ${isSelected ? `
          <svg class="h-5 w-5 text-indigo-600 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20">
            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
          </svg>
        ` : ''}
      </button>
    `;
  }

  function selectNotionDestination(id, type) {
    selectedDestinationId = id;
    selectedDestinationType = type;
    createNewPage = false; // Reset when changing destination
    renderNotionDestinations(notionDestinations);
    updateCreateNewPageOption();
  }

  function updateCreateNewPageOption() {
    const container = document.getElementById('create-new-page-option');
    const titleInput = document.getElementById('create-new-page-title');
    if (!container) return;
    
    // Only show "create new page" option for page destinations
    if (selectedDestinationType === 'page') {
      container.classList.remove('hidden');
      const checkbox = document.getElementById('create-new-page-checkbox');
      if (checkbox) checkbox.checked = createNewPage;
      if (titleInput && !titleInput.value) {
        titleInput.value = meetingTitle;
        customSubpageTitle = titleInput.value;
      }
    } else {
      container.classList.add('hidden');
      createNewPage = false;
      customSubpageTitle = '';
      if (titleInput) titleInput.value = '';
    }
  }

  function toggleCreateNewPage() {
    createNewPage = document.getElementById('create-new-page-checkbox')?.checked || false;
    const titleInput = document.getElementById('create-new-page-title');
    if (createNewPage && titleInput && !titleInput.value) {
      titleInput.value = meetingTitle;
      customSubpageTitle = titleInput.value;
    }
  }

  function filterNotionDestinations() {
    const query = document.getElementById('notion-destination-search').value.toLowerCase();
    const filtered = notionDestinations.filter(d => 
      d.title.toLowerCase().includes(query)
    );
    renderNotionDestinations(filtered);
  }

  async function publishToSelectedNotionDestination() {
    if (!selectedDestinationId || !publishArtifactId) return;
    
    const btn = document.getElementById('notion-publish-btn');
    const btnText = btn.querySelector('span');
    const originalText = btnText.textContent;
    
    btn.disabled = true;
    btnText.textContent = 'Publishing...';
    
    try {
      const selectedDest = notionDestinations.find(d => d.id === selectedDestinationId);
      const titleTemplate = (document.getElementById('create-new-page-title')?.value || '').trim();
      customSubpageTitle = titleTemplate;
      
      const response = await fetch(`/api/meetings/${publishArtifactId}/publish/notion`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          destinationId: selectedDestinationId,
          destinationType: selectedDest?.type || 'database',
          createNewPage: createNewPage,
          titleTemplate: titleTemplate || undefined,
        }),
      });
      
      const result = await response.json();
      
      if (!response.ok) {
        throw new Error(result.message || result.error || 'Failed to publish');
      }
      
      closeNotionDestinationPicker();
      showNotification(result.message || 'Publishing to Notion...', 'success');
      
      // Reload after a delay to show updated status
      setTimeout(() => window.location.reload(), 3000);
    } catch (error) {
      console.error('Error publishing to Notion:', error);
      showNotification(error.message || 'Failed to publish to Notion', 'error');
      btn.disabled = false;
      btnText.textContent = originalText;
    }
  }

  // ===== Slack Destination Picker =====
  let slackChannels = [];
  let selectedSlackChannelId = null;
  let createSlackChannelName = '';
  let inviteAllSlack = false;

  async function openSlackDestinationPicker(artifactId) {
    publishArtifactId = artifactId;
    const modal = document.getElementById('slack-destination-modal');
    const listContainer = document.getElementById('slack-channels-list');
    const loadingEl = document.getElementById('slack-channels-loading');
    const errorEl = document.getElementById('slack-channels-error');
    const createNameInput = document.getElementById('slack-create-channel-name');
    const inviteAllCheckbox = document.getElementById('slack-invite-all-checkbox');
    selectedSlackChannelId = null;
    createSlackChannelName = '';
    inviteAllSlack = false;
    createNameInput.value = '';
    inviteAllCheckbox.checked = false;
    listContainer.innerHTML = '';
    loadingEl.classList.remove('hidden');
    errorEl.classList.add('hidden');
    document.getElementById('slack-publish-btn').disabled = true;
    modal.classList.remove('hidden');

    try {
      const resp = await fetch('/api/slack/channels');
      const data = await resp.json();
      if (!resp.ok) throw new Error(data.error || 'Failed to load Slack channels');
      slackChannels = data.channels || [];
      selectedSlackChannelId = slackChannels[0]?.id || null;
      renderSlackChannels(slackChannels);
      document.getElementById('slack-publish-btn').disabled = !(selectedSlackChannelId || createSlackChannelName);
    } catch (err) {
      console.error('Error loading Slack channels:', err);
      errorEl.textContent = err.message || 'Failed to load Slack channels. Please connect Slack in Settings.';
      errorEl.classList.remove('hidden');
    } finally {
      loadingEl.classList.add('hidden');
    }
  }

  function closeSlackDestinationPicker() {
    document.getElementById('slack-destination-modal').classList.add('hidden');
  }

  function renderSlackChannels(channels) {
    const listContainer = document.getElementById('slack-channels-list');
    if (!channels.length) {
      listContainer.innerHTML = '<p class="text-xs text-gray-500">No channels found. Create one below.</p>';
      return;
    }
    listContainer.innerHTML = channels.map(ch => `
      <button
        type="button"
        onclick="selectSlackChannel('${ch.id}', '${ch.name}')"
        class="w-full flex items-center px-3 py-2 rounded-lg text-left transition-colors ${selectedSlackChannelId === ch.id ? 'bg-sky-50 ring-2 ring-sky-500 text-sky-700' : 'hover:bg-gray-50 text-gray-700'}"
      >
        <div class="flex-1 min-w-0">
          <p class="text-sm font-medium truncate">#${ch.name}</p>
          <p class="text-xs text-gray-500">${ch.isPrivate ? 'Private' : 'Public'}</p>
        </div>
        ${selectedSlackChannelId === ch.id ? `<svg class="h-5 w-5 text-sky-600 flex-shrink-0" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/></svg>` : ''}
      </button>
    `).join('');
  }

  function selectSlackChannel(id, name) {
    selectedSlackChannelId = id;
    createSlackChannelName = '';
    document.getElementById('slack-create-channel-name').value = '';
    document.getElementById('slack-publish-btn').disabled = false;
    renderSlackChannels(slackChannels);
  }

  function onSlackCreateNameInput(val) {
    createSlackChannelName = val.trim();
    if (createSlackChannelName) {
      selectedSlackChannelId = null;
    }
    document.getElementById('slack-publish-btn').disabled = !(selectedSlackChannelId || createSlackChannelName);
    renderSlackChannels(slackChannels);
  }

  async function publishToSlackSelected() {
    if (!publishArtifactId) return;
    const btn = document.getElementById('slack-publish-btn');
    const btnText = btn.querySelector('span');
    const originalText = btnText.textContent;
    btn.disabled = true;
    btnText.textContent = 'Publishing...';
    const payload = {
      channelId: selectedSlackChannelId,
      channelName: slackChannels.find(c => c.id === selectedSlackChannelId)?.name || null,
      createChannelName: createSlackChannelName || undefined,
      inviteAll: document.getElementById('slack-invite-all-checkbox').checked,
    };
    try {
      const resp = await fetch(`/api/meetings/${publishArtifactId}/publish/slack`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      const data = await resp.json();
      if (!resp.ok) throw new Error(data.error || 'Failed to publish to Slack');
      closeSlackDestinationPicker();
      showNotification('Publishing to Slack...', 'info');
      setTimeout(() => window.location.reload(), 1500);
    } catch (err) {
      console.error('Slack publish error:', err);
      showNotification(err.message || 'Failed to publish to Slack', 'error');
      btn.disabled = false;
      btnText.textContent = originalText;
    }
  }

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function copyShareLink(shareId, link) {
    navigator.clipboard.writeText(link).then(() => {
      showNotification('Share link copied to clipboard!', 'success');
      const btn = document.querySelector(`#share-link-${shareId}`).nextElementSibling;
      if (btn) {
        const originalHTML = btn.innerHTML;
        btn.innerHTML = '<svg class="w-3 h-3" fill="currentColor" viewBox="0 0 20 20"><path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"/></svg>';
        setTimeout(() => {
          btn.innerHTML = originalHTML;
        }, 2000);
      }
    }).catch(err => {
      console.error('Failed to copy:', err);
      showNotification('Failed to copy link', 'error');
    });
  }

  async function generateShareToken(shareId) {
    try {
      const response = await fetch(`/api/meetings/${shareMeetingId}/shares/${shareId}/generate-token`, {
        method: 'POST',
      });
      
      const data = await response.json();
      
      if (!response.ok) {
        throw new Error(data.error || 'Failed to generate token');
      }
      
      showNotification('Shareable link generated!', 'success');
      loadCurrentShares(); // Reload to show the new link
    } catch (error) {
      console.error('Error generating share token:', error);
      showNotification(error.message || 'Failed to generate shareable link', 'error');
    }
  }
</script>

<!-- Slack Destination Picker Modal -->
<div id="slack-destination-modal" class="hidden fixed inset-0 z-50 overflow-y-auto" aria-labelledby="modal-title" role="dialog" aria-modal="true">
  <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
    <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" onclick="closeSlackDestinationPicker()"></div>
    <div class="inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full sm:p-6">
      <div class="absolute top-0 right-0 pt-4 pr-4">
        <button type="button" onclick="closeSlackDestinationPicker()" class="bg-white rounded-md text-gray-400 hover:text-gray-500 focus:outline-none">
          <span class="sr-only">Close</span>
          <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
      <div class="sm:flex sm:items-start">
        <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-sky-100 sm:mx-0 sm:h-10 sm:w-10">
          <svg class="h-6 w-6 text-sky-600" viewBox="0 0 24 24" fill="currentColor">
            <path d="M5.1 15.9c0 1.05-.86 1.9-1.9 1.9S1.3 16.95 1.3 15.9s.86-1.9 1.9-1.9h1.9v1.9zm.95 0c0-1.05.86-1.9 1.9-1.9s1.9.85 1.9 1.9v4.75c0 1.05-.86 1.9-1.9 1.9s-1.9-.85-1.9-1.9V15.9zm1.9-10.85c-1.05 0-1.9-.86-1.9-1.9S6 1.25 7.05 1.25 8.95 2.1 8.95 3.15v1.9H7.05zm0 .95c1.05 0 1.9.86 1.9 1.9s-.86 1.9-1.9 1.9H2.3c-1.05 0-1.9-.86-1.9-1.9S1.25 6 2.3 6h4.75zM18.9 8.05c0-1.05.86-1.9 1.9-1.9s1.9.86 1.9 1.9-.86 1.9-1.9 1.9h-1.9v-1.9zm-.95 0c0 1.05-.86 1.9-1.9 1.9s-1.9-.86-1.9-1.9V3.3c0-1.05.86-1.9 1.9-1.9s1.9.86 1.9 1.9v4.75zm-1.9 10.85c1.05 0 1.9.86 1.9 1.9s-.86 1.9-1.9 1.9-1.9-.86-1.9-1.9v-1.9h1.9zm0-.95c-1.05 0-1.9-.86-1.9-1.9s.86-1.9 1.9-1.9h4.75c1.05 0 1.9.86 1.9 1.9s-.86 1.9-1.9 1.9H16.05z"/>
          </svg>
        </div>
        <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left flex-1">
          <h3 class="text-lg leading-6 font-medium text-gray-900">Publish to Slack</h3>
          <p class="mt-1 text-sm text-gray-500">Choose a channel or create a new one to post this meeting.</p>
        </div>
      </div>

      <div class="mt-4">
        <div id="slack-channels-loading" class="mt-4 text-center py-6">
          <svg class="animate-spin h-8 w-8 text-sky-600 mx-auto" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          <p class="mt-2 text-sm text-gray-500">Loading Slack channels...</p>
        </div>
        <div id="slack-channels-error" class="hidden mt-2 p-3 bg-red-50 rounded-md text-sm text-red-700"></div>
        <div id="slack-channels-list" class="mt-2 max-h-56 overflow-y-auto space-y-1"></div>

        <div class="mt-4 space-y-2">
          <label class="block text-xs font-medium text-gray-700">Or create a new channel</label>
          <input
            type="text"
            id="slack-create-channel-name"
            placeholder="e.g., meeting-recaps"
            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-sky-500 focus:ring-sky-500 sm:text-sm"
            oninput="onSlackCreateNameInput(this.value)"
          />
          <div class="flex items-center space-x-2 mt-2">
            <input
              type="checkbox"
              id="slack-invite-all-checkbox"
              class="h-4 w-4 text-sky-600 border-gray-300 rounded focus:ring-sky-500"
            />
            <label for="slack-invite-all-checkbox" class="text-xs text-gray-700">Invite all users</label>
          </div>
        </div>
      </div>

      <div class="mt-5 sm:mt-4 sm:flex sm:flex-row-reverse gap-3">
        <button
          type="button"
          id="slack-publish-btn"
          onclick="publishToSlackSelected()"
          disabled
          class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-sky-600 text-base font-medium text-white hover:bg-sky-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 sm:w-auto sm:text-sm disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <span>Publish to Selected</span>
        </button>
        <button
          type="button"
          onclick="closeSlackDestinationPicker()"
          class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-sky-500 sm:mt-0 sm:w-auto sm:text-sm"
        >
          Cancel
        </button>
      </div>
    </div>
  </div>
</div>

<!-- Notion Destination Picker Modal -->
<div id="notion-destination-modal" class="hidden fixed inset-0 z-50 overflow-y-auto" aria-labelledby="modal-title" role="dialog" aria-modal="true">
  <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0">
    <!-- Background overlay -->
    <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity" onclick="closeNotionDestinationPicker()"></div>

    <!-- Modal panel -->
    <div class="inline-block align-bottom bg-white rounded-lg px-4 pt-5 pb-4 text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full sm:p-6">
      <div class="absolute top-0 right-0 pt-4 pr-4">
        <button type="button" onclick="closeNotionDestinationPicker()" class="bg-white rounded-md text-gray-400 hover:text-gray-500 focus:outline-none">
          <span class="sr-only">Close</span>
          <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
          </svg>
        </button>
      </div>
      
      <div class="sm:flex sm:items-start">
        <div class="mx-auto flex-shrink-0 flex items-center justify-center h-12 w-12 rounded-full bg-indigo-100 sm:mx-0 sm:h-10 sm:w-10">
          <svg class="h-6 w-6 text-indigo-600" viewBox="0 0 24 24" fill="currentColor">
            <path d="M4.459 4.208c.746.606 1.026.56 2.428.466l13.215-.793c.28 0 .047-.28-.046-.326L17.86 2.02c-.42-.326-.98-.7-2.055-.607L3.01 2.72c-.466.046-.56.28-.374.466l1.823 1.022zm.793 3.08v13.904c0 .747.373 1.027 1.214.98l14.523-.84c.841-.046.935-.56.935-1.166V6.354c0-.606-.233-.933-.748-.886l-15.177.887c-.56.047-.747.327-.747.933zm14.337.745c.093.42 0 .84-.42.888l-.7.14v10.264c-.608.327-1.168.514-1.635.514-.748 0-.935-.234-1.495-.933l-4.577-7.186v6.952l1.448.327s0 .84-1.168.84l-3.22.186c-.094-.186 0-.653.327-.746l.84-.233V9.854L7.822 9.76c-.094-.42.14-1.026.793-1.073l3.456-.233 4.764 7.279v-6.44l-1.215-.14c-.093-.514.28-.886.747-.933l3.222-.186zM2.877 1.16l13.681-.933c1.682-.14 2.101.093 2.801.606l3.876 2.754c.466.326.606.7.606 1.213v15.06c0 .933-.373 1.493-1.682 1.586l-15.457.933c-.98.047-1.448-.093-1.962-.7l-3.129-4.06c-.56-.747-.793-1.306-.793-1.96V2.667c0-.839.374-1.54 1.682-1.633l.377.126z"/>
          </svg>
        </div>
        <div class="mt-3 text-center sm:mt-0 sm:ml-4 sm:text-left flex-1">
          <h3 class="text-lg leading-6 font-medium text-gray-900" id="modal-title">
            Publish to Notion
          </h3>
          <p class="mt-1 text-sm text-gray-500">
            Select a Notion page or database to publish this meeting's notes.
          </p>
        </div>
      </div>
      
      <!-- Search -->
      <div class="mt-4">
        <input
          type="text"
          id="notion-destination-search"
          placeholder="Search pages and databases..."
          oninput="filterNotionDestinations()"
          class="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
        />
      </div>
      
      <!-- Loading state -->
      <div id="notion-destinations-loading" class="mt-4 text-center py-8">
        <svg class="animate-spin h-8 w-8 text-indigo-600 mx-auto" fill="none" viewBox="0 0 24 24">
          <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
          <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
        <p class="mt-2 text-sm text-gray-500">Loading Notion destinations...</p>
      </div>
      
      <!-- Error state -->
      <div id="notion-destinations-error" class="hidden mt-4 p-4 bg-red-50 rounded-md">
        <p class="text-sm text-red-700"></p>
      </div>
      
      <!-- Destinations list -->
      <div id="notion-destinations-list" class="mt-4 max-h-64 overflow-y-auto">
        <!-- Populated by JavaScript -->
      </div>
      
      <!-- Create new page option (only shown for page destinations) -->
      <div id="create-new-page-option" class="hidden mt-4 p-3 bg-gray-50 rounded-lg border border-gray-200">
        <label class="flex items-center cursor-pointer">
          <input
            type="checkbox"
            id="create-new-page-checkbox"
            onchange="toggleCreateNewPage()"
            class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 rounded"
          />
          <div class="ml-3">
            <span class="text-sm font-medium text-gray-900">Create new subpage</span>
            <p class="text-xs text-gray-500">Creates a new page under the selected page instead of appending content</p>
          </div>
        </label>
        <div class="mt-3">
          <label for="create-new-page-title" class="block text-xs font-medium text-gray-700 mb-1">
            Subpage title (optional)
          </label>
          <input
            type="text"
            id="create-new-page-title"
            placeholder="Defaults to meeting title"
            class="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
            oninput="customSubpageTitle = this.value"
          />
        </div>
      </div>
      
      <!-- Actions -->
      <div class="mt-5 sm:mt-4 sm:flex sm:flex-row-reverse gap-3">
        <button
          type="button"
          id="notion-publish-btn"
          onclick="publishToSelectedNotionDestination()"
          disabled
          class="w-full inline-flex justify-center rounded-md border border-transparent shadow-sm px-4 py-2 bg-indigo-600 text-base font-medium text-white hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:w-auto sm:text-sm disabled:opacity-50 disabled:cursor-not-allowed"
        >
          <span>Publish to Selected</span>
        </button>
        <button
          type="button"
          onclick="closeNotionDestinationPicker()"
          class="mt-3 w-full inline-flex justify-center rounded-md border border-gray-300 shadow-sm px-4 py-2 bg-white text-base font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 sm:mt-0 sm:w-auto sm:text-sm"
        >
          Cancel
        </button>
      </div>
    </div>
  </div>
</div>

<%- include('partials/footer') -%>
